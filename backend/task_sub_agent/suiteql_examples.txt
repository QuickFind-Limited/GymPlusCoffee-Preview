Gym+Coffee SuiteQL Examples and Patterns
======================================

These samples capture approved query patterns used in Gym+Coffee's NetSuite environment. The suiteql subagent must use these as inspiration when composing new SQL and always adjust filters, joins, and grouping to the user's request.

------------------------------------------------------------
1. Retail Sales by Store (Water Bottles, Q1 2025)
------------------------------------------------------------

Goal
----
Summarize net sales and units for water bottles across retail stores for Januaryâ€“March 2025.

Key points
----------
- Filters on item names containing "bottle" while excluding bottle accessories.
- Joins transaction, transactionline, item, customer, location.
- Filters posting = 'T', mainline = 'F'.
- Net sales is SUM(tranline.amount) (negative for sales). Units is SUM(tranline.quantity).
- Groups by location and month.

Example
-------
```sql
WITH bottle_items AS (
  SELECT id
  FROM item
  WHERE 
    (LOWER(displayname) LIKE '%bottle%' OR LOWER(description) LIKE '%bottle%')
    AND LOWER(displayname) NOT LIKE '%replacement cap%'
)
SELECT
  loc.name AS store_name,
  TO_CHAR(tran.trandate, 'YYYY-MM') AS year_month,
  -SUM(line.amount) AS net_sales_eur,
  -SUM(line.quantity) AS units_sold
FROM transactionline line
JOIN transaction tran ON tran.id = line.transaction
JOIN bottle_items bi ON bi.id = line.item
JOIN location loc ON loc.id = tran.location
WHERE
  tran.mainline = 'F'
  AND tran.posting = 'T'
  AND tran.trandate BETWEEN :start_date AND :end_date
  AND tran.location IN (:location_ids)
GROUP BY store_name, year_month
ORDER BY store_name, year_month;
```

------------------------------------------------------------
2. Net Margin by Product Family (Retail, Q2 2025)
------------------------------------------------------------

Goal
----
Calculate net sales, COGS, and gross margin percent by product family for retail stores.

Key points
----------
- Revenue lines: accounttype = 'Income'. COGS lines: accounttype = 'COGS'.
- Negative revenue values indicate sales; COGS lines are positive (no sign flips).
- Uses interim CTEs for revenue and cogs, then joins on item and period.
- Margin percent = (net_sales + cogs) / net_sales.

Example
-------
```sql
WITH revenue AS (
  SELECT
    line.item,
    TO_CHAR(tran.trandate, 'YYYY-MM') AS year_month,
    -SUM(line.amount) AS net_sales
  FROM transactionline line
  JOIN transaction tran ON tran.id = line.transaction
  WHERE tran.posting = 'T'
    AND tran.mainline = 'F'
    AND line.accounttype = 'Income'
    AND tran.location IN (:retail_locations)
    AND tran.trandate BETWEEN :start_date AND :end_date
  GROUP BY line.item, TO_CHAR(tran.trandate, 'YYYY-MM')
),
cogs AS (
  SELECT
    line.item,
    TO_CHAR(tran.trandate, 'YYYY-MM') AS year_month,
    SUM(line.amount) AS cogs_amount
  FROM transactionline line
  JOIN transaction tran ON tran.id = line.transaction
  WHERE tran.posting = 'T'
    AND tran.mainline = 'F'
    AND line.accounttype = 'COGS'
    AND tran.location IN (:retail_locations)
    AND tran.trandate BETWEEN :start_date AND :end_date
  GROUP BY line.item, TO_CHAR(tran.trandate, 'YYYY-MM')
)
SELECT
  item.department AS product_family,
  rev.year_month,
  SUM(rev.net_sales) AS net_sales,
  SUM(cogs.cogs_amount) AS cogs,
  CASE WHEN SUM(rev.net_sales) <> 0
       THEN (SUM(rev.net_sales) + SUM(cogs.cogs_amount)) / SUM(rev.net_sales)
       ELSE NULL
  END AS gross_margin_pct
FROM revenue rev
LEFT JOIN cogs ON cogs.item = rev.item AND cogs.year_month = rev.year_month
JOIN item ON item.id = rev.item
GROUP BY item.department, rev.year_month
ORDER BY item.department, rev.year_month;
```

------------------------------------------------------------
3. Returns vs Sales (Retail vs Web)
----------------------------------

Goal
----
Compare net sales and returns between retail stores and web store for a specified quarter.

Key points
----------
- Uses CASE expressions to categorize channel based on location and customer fields.
- Returns captured by summing positive amounts where quantity is positive but amount negative (or repricing). Alternatively track transaction types (cash refund, return authorization) depending on dataset.
- Example includes separate columns for gross sales, returns, net sales.

Example
-------
```sql
SELECT
  CASE
    WHEN loc.name IN (:retail_locations) THEN 'Retail Stores'
    WHEN cust.category = 'Web Store' THEN 'Web Store'
    ELSE 'Other'
  END AS channel,
  SUM(CASE WHEN line.amount < 0 THEN -line.amount ELSE 0 END) AS gross_sales,
  SUM(CASE WHEN line.amount > 0 THEN line.amount ELSE 0 END) AS returns,
  SUM(-line.amount) AS net_sales
FROM transactionline line
JOIN transaction tran ON tran.id = line.transaction
JOIN location loc ON loc.id = tran.location
LEFT JOIN customer cust ON cust.id = tran.entity
WHERE tran.posting = 'T'
  AND tran.mainline = 'F'
  AND line.accounttype = 'Income'
  AND tran.trandate BETWEEN :start_date AND :end_date
GROUP BY channel
ORDER BY channel;
```

------------------------------------------------------------
4. Inventory Snapshot (Retail vs Warehouse)
------------------------------------------

Goal
----
Capture on-hand inventory by location grouping (retail vs warehouse) for a given date.

Key points
----------
- Uses inventorybalance or inventoryitemlocation (depending on availability) to compute quantity on hand.
- Groups by location category (retail store vs 3PL). Example uses CASE on location name.
- Shows total on hand and value (quantity * averagecost).

Example
-------
```sql
SELECT
  CASE
    WHEN loc.name IN (:retail_locations) THEN 'Retail Store'
    WHEN loc.name LIKE 'Bleckmann%' THEN 'Warehouse/3PL'
    ELSE 'Other'
  END AS location_group,
  loc.name AS location_name,
  item.displayname AS item_name,
  inv.onhand AS quantity_on_hand,
  inv.onhandvalue AS inventory_value
FROM inventorybalance inv
JOIN item ON item.id = inv.item
JOIN location loc ON loc.id = inv.location
WHERE inv.asofdate = :snapshot_date
  AND inv.location IN (:tracked_locations)
ORDER BY location_group, location_name, item_name
FETCH NEXT 500 ROWS ONLY;
```

------------------------------------------------------------
5. Purchase Orders Awaiting Receipt
----------------------------------

Goal
----
List open purchase orders for key vendors with outstanding quantity.

Key points
----------
- Filters transactiontype = 'PurchOrd', status NOT IN received/closed states.
- Compares quantity ordered vs received.
- Includes vendor, PO number, expected receipt date, open quantity, open value.

Example
-------
```sql
SELECT
  tran.tranid AS purchase_order,
  vendor.entityid AS vendor_name,
  tran.duedate,
  line.item_display AS item_name,
  line.quantity AS ordered_qty,
  line.quantityreceived AS received_qty,
  (line.quantity - line.quantityreceived) AS open_qty,
  (line.rate * (line.quantity - line.quantityreceived)) AS open_value
FROM transactionline line
JOIN transaction tran ON tran.id = line.transaction
JOIN vendor ON vendor.id = tran.entity
WHERE tran.type = 'PurchOrd'
  AND tran.status NOT IN ('PurchOrd:C', 'PurchOrd:H')
  AND (line.quantity - line.quantityreceived) > 0
  AND tran.trandate BETWEEN :start_date AND :end_date
ORDER BY vendor_name, tran.duedate;
```

------------------------------------------------------------
Usage Guidance
------------------------------------------------------------

1. Always update filters (dates, locations, item identification) to match the user's request.
2. Apply Gym+Coffee language rules, summing signed values, and respecting payment-term classification.
3. When the NetSuite schema differs (e.g., custom fields, transactions), mention assumptions and request clarification.
4. Use FETCH NEXT to protect against large result sets; default to 500 rows unless the task calls for a different limit.
5. Report findings in business language, highlighting anomalies (margins outside 10-70%, price outliers below known thresholds).
6. If RunQuery returns an error, capture the error message, adjust the SQL, and re-run until a valid result is achieved or the limitation is explained.
